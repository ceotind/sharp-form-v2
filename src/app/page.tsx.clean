'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { initializeApp } from 'firebase/app';
import { getFirestore } from 'firebase/firestore';
import { doc, setDoc, serverTimestamp, collection, query, orderBy, onSnapshot, deleteDoc, updateDoc } from 'firebase/firestore';
import { v4 as uuidv4 } from 'uuid';
import { FormField } from '@/types/form';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';
import { SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy, arrayMove } from '@dnd-kit/sortable';
import { FormBuilder } from '@/components/form-elements/FormBuilder';
import { SortableField } from '@/components/form-elements/SortableField';
import { Save, Plus, BarChart2 } from 'lucide-react';
import { useToast } from '@/components/ui/use-toast';
import { Switch } from '@/components/ui/switch';
import { Label } from '@/components/ui/label';
import FormBuilderLayout from '@/components/FormBuilderLayout';
import { formElementRegistry } from '@/components/form-elements/registry/FormElementRegistry';

// Import form elements to register them
import '@/components/form-elements/elements/TextInput';
import '@/components/form-elements/elements/TextareaInput';
import '@/components/form-elements/elements/SelectInput';
import '@/components/form-elements/elements/CheckboxInput';
import '@/components/form-elements/elements/RadioGroup';
import '@/components/form-elements/elements/DateInput';

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

export default function CreateFormPage() {
  const router = useRouter();
  const { toast } = useToast();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [formTitle, setFormTitle] = useState('Untitled Form');
  const [formDescription, setFormDescription] = useState('');
  const [fields, setFields] = useState<FormField[]>([]);
  const [isPublishing, setIsPublishing] = useState(false);
  const [editingField, setEditingField] = useState<FormField | null>(null);
  const [selectedFormId, setSelectedFormId] = useState<string | null>(null);
  const [forms, setForms] = useState<any[]>([]);

  // Theme state
  const [themeBackground, setThemeBackground] = useState('');
  const [textColor, setTextColor] = useState('');
  const [accentColor, setAccentColor] = useState('');
  const [themeSaving, setThemeSaving] = useState(false);
  const [themeSaveMsg, setThemeSaveMsg] = useState('');

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: { distance: 8 },
    }),
    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })
  );

  useEffect(() => {
    const q = query(collection(db, 'forms'), orderBy('createdAt', 'desc'));
    const unsubscribe = onSnapshot(q, (snapshot) => {
      const formsList = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      setForms(formsList);
    });
    return () => unsubscribe();
  }, []);

  // Handle drag and drop for fields
  const handleDragEnd = (event: any) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      setFields((items) => {
        const oldIndex = items.findIndex((item) => item.id === active.id);
        const newIndex = items.findIndex((item) => item.id === over.id);
        return arrayMove(items, oldIndex, newIndex);
      });
    }
  };

  // Handle field changes from FormBuilder
  const handleFieldsChange = (newFields: FormField[]) => {
    setFields(newFields);
  };

  // Handle field selection
  const handleFieldSelect = (field: FormField) => {
    setEditingField(field);
  };

  // Update field
  const handleFieldUpdate = (updatedField: FormField) => {
    setFields(prev => prev.map(field => 
      field.id === updatedField.id ? updatedField : field
    ));
    setEditingField(null);
  };

  // Publish form
  const handlePublish = async () => {
    if (!formTitle.trim()) {
      setError('Please enter a form title');
      return;
    }

    setIsPublishing(true);
    setError(null);

    try {
      const formId = uuidv4();

      // Create form data with required fields
      const formData = {
        id: formId,
        title: formTitle.trim(),
        createdAt: new Date().toISOString(),
        ipAddress: '',
        metadata: {
          lastModified: new Date().toISOString(),
          created: new Date().toISOString(),
          creatorIp: ''
        },
        description: formDescription.trim() || null,
        fields: fields.length > 0 ? fields : [],
        settings: {
          allowMultipleResponses: true,
          customSuccessMessage: 'Thank you for your submission!',
          customErrorMessage: 'There was an error submitting your form. Please try again.',
          themeBackground: themeBackground || '',
          textColor: textColor || '',
          accentColor: accentColor || ''
        }
      };

      // Save to Firebase
      await setDoc(doc(db, 'forms', formId), formData);
      
      router.push(`/forms/${formId}`);

    } catch (err) {
      console.error('Error creating form:', err);
      setError('Failed to create form. Please try again.');
    } finally {
      setIsPublishing(false);
    }
  };

  // Save theme settings
  const handleThemeSave = async (formId: string) => {
    setThemeSaving(true);
    setThemeSaveMsg('');
    try {
      await updateDoc(doc(db, 'forms', formId), {
        'settings.themeBackground': themeBackground,
        'settings.textColor': textColor,
        'settings.accentColor': accentColor,
      });
      setThemeSaveMsg('Theme updated!');
    } catch (e) {
      setThemeSaveMsg('Failed to update theme.');
    } finally {
      setThemeSaving(false);
    }
  };

  async function deleteForm(id: string) {
    await deleteDoc(doc(db, 'forms', id));
  }

  const handleEditForm = async (formId: string) => {
    const form = forms.find(f => f.id === formId);
    if (form) {
      setFormTitle(form.title);
      setFormDescription(form.description || '');
      setFields(form.fields);
      if (form.settings) {
        setThemeBackground(form.settings.themeBackground || '');
        setTextColor(form.settings.textColor || '');
        setAccentColor(form.settings.accentColor || '');
      }
      setSelectedFormId(formId);
    }
  };

  const handleUpdateForm = async () => {
    if (!selectedFormId) return;
    
    try {
      setIsPublishing(true);
